<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tickets</title>
    {% load static %}
    <link rel="stylesheet" type="text/css" href="{% static 'css/main.css' %}">
    <link rel="stylesheet" type="text/css" href="{% static 'css/tickets.css' %}">
    <link rel="icon" type="image/png" href="{% static 'icons/print.svg' %}"/>
</head>
<body>
    <div id="content">
        <h1>Sort Ticket Request #{{pk}}</h1>
        <p class="info">Date Created: {{ date }}</p>
        <table id="groups">
            <tr>
                <th>Group</th>
                <th>Number of Tickets</th>
                <th>Tickets PDF</th>
              </tr>
        </table>
        <button id="generate_all">Generate All</button>
        <p id="error" style="color: red;" hidden></p>
    </div>
</body>
<script>
    // Generate table
    const table = document.getElementById("groups");
    const group_data = {{ group_data|safe }};
    const NUM_TICKETS_PER_PDF = {{num_tickets_per_pdf}};
    let generating = [];

    async function printPart(group, part) {
        const partName = `${group}_${part}`;
        generating.push(partName);
        return new Promise((resolve) => {
            fetch("{% url 'ticketing:api_print' %}?" + new URLSearchParams({
                'pk': "{{ pk }}",
                "group": group,
                "part": part
            }))
                .then((response) => {
                    if (response.ok) {
                        return response.json();
                    } else {
                        throw new Error(`${response.status} ${response.statusText}.`);
                    }
                })
                .then((data) => {
                    group_data[group].num_tickets_printed += NUM_TICKETS_PER_PDF;
                    generating.splice(generating.indexOf(partName), 1);
                    refresh();
                    resolve();
                }).catch((error) => {
                    document.getElementById('error').hidden = false;
                    document.getElementById('error').innerText = error;
            });
        });
    }

    function refresh() {
        // clear table
        let table_length = table.rows.length;
        for (let i = 1; i < table_length; i++) {
            table.deleteRow(1);
        }

        // rebuild table
        for (let group of Object.keys(group_data)) {
            let row = table.insertRow(table.rows.length);
            row.id = group;

            let group_code = row.insertCell(0);
            group_code.innerHTML = group;

            let num_tickets = row.insertCell(1);
            num_tickets.innerHTML = group_data[group]["num_tickets"];

            let tickets_pdf_row = row.insertCell(2);
            let tickets_pdf = document.createElement('div');
            tickets_pdf.id = `${group}_pdf`;
            tickets_pdf.classList.add("tickets_pdf");
            tickets_pdf_row.appendChild(tickets_pdf);

            if (group_data[group]["num_tickets"] === 0) {
                tickets_pdf.innerHTML = "No Tickets :(";

            } else {
                const num_parts_required = Math.ceil(group_data[group].num_tickets / NUM_TICKETS_PER_PDF);
                const num_parts_done = group_data[group].num_tickets_printed / NUM_TICKETS_PER_PDF;
                for (let part = 1; part <= num_parts_required; part++) {
                    if (part <= num_parts_done) {
                        // if part has been completed
                        const link = document.createElement('a');
                        const text = document.createTextNode((num_parts_required === 1) ? "Download" : `Part${part} `);
                        link.appendChild(text);
                        link.title = (num_parts_required === 1) ? `PDF of tickets for group ${group}` : `PDF of tickets for group ${group} (part ${part})`;
                        link.href = `${"{{pk}}"}/${group}/${part}`;
                        tickets_pdf.appendChild(link);
                    } else {
                        // if part has not been completed
                        let generate_button = document.createElement('button');
                        const partName = `${group}_${part}`;
                        if (generating.includes(partName)) {
                            // if currently generating
                            generate_button.disabled = true;
                            generate_button.innerHTML = (num_parts_required === 1) ? "Generating" : `Part ${part}...`;
                        } else {
                            // if not yet generated
                            generate_button.innerHTML = (num_parts_required === 1) ? "Generate" : `Part ${part}`;
                            generate_button.onclick = (event) => {
                                document.getElementById('error').hidden = true;
                                generate_button.disabled = true;
                                generate_button.innerHTML = (num_parts_required === 1) ? "Generating" : `Part ${part}...`;
                                printPart(group, part);
                            };
                        }
                        tickets_pdf.appendChild(generate_button);
                    }
                }
            }
            refresh_generate_all();
        }
    }

    /* Generate All Button */
    let generate_all_button = document.getElementById('generate_all');

    function isGroupDone(group) {
        return group_data[group].num_tickets_printed >= group_data[group].num_tickets;
    }
    function hasCompletedAll() {
        for (let group of Object.keys(group_data)) {
            if (!isGroupDone(group)) return false;
        }
        return true;
    }

    function refresh_generate_all() {
        generate_all_button.hidden = hasCompletedAll();
    }

    generate_all_button.onclick = async () => {
        document.getElementById('error').hidden = true;

        // get the groups which haven't been printed yet
        const groups = Object.keys(group_data).filter((group) => {return !isGroupDone(group)});
        generating = generating.concat(groups);

        // disable further print requests
        refresh();

        generate_all_button.innerHTML = "Generating all...";
        generate_all_button.disabled = true;

        for (let group of groups) {
            const num_parts_required = Math.ceil(group_data[group].num_tickets / NUM_TICKETS_PER_PDF);
            const num_parts_done = group_data[group].num_tickets_printed / NUM_TICKETS_PER_PDF;
            for (let part = num_parts_done + 1; part <= num_parts_required; part++) {
                await printPart(group, part);
            }
        }
    };

    refresh();
</script>
</html>